## Альтернация и скобочные группы. Опережающая проверка
Давайте попробуем найти дату в подстроке:
```
const s = '20.10.19 Ваша заявка с номером #478354 оформлена';
```

Мы можем попробовать написать так:
`/\d{2}.\d{2}.\d{2,4}/`

Насколько это рабочий код?  
В целом, он сработает, но под него попадут и другие выражения, а именно:  
`32.43.467`, `34G46C45`

Тут нам на помощь приходит символ `альтернации` - `|`;  
На самом деле такой же оператор есть и в Js - это побитовое "или" - `|`, а
две вертикальные палки - это логическое "или" - `||`;

`\d{2}\.\d{2}\.(\d{2}|\d{4})` - новая версия нашего кода.
Она уже больше похожа на правду. Проблем как в прошлый раз не будет, зато есть нюанс:
В строке '20.10.1945' нам вернется '20.10.19', потому что альтернация сработает, если
у нас не удалось найти в первый раз, тк он читает слева направо.

А скобки создают группу, группировку.

Но наше регулярное выражение все еще работает не до конца правильно:
`19.34.567` также вернет нам подстроку `19.34.56` с нашим регулярным выражением.

Давайте попробуем переписать нашу регулярку (`\d{2}\.\d{2}\.(\d{4}|\d{2})`):
`\d{2}\.\d{2}\.(\d{4}|\d{2}(?!\d))`

Как читать такое регулярное выражение?
С первой частью думаю все понятно. Вторая часть:  
`(\d{4}|\d{2}(?!\d))` - либо у нас идет 4 цифры подряд, либо у нас идет 2 цифры подряд И
дальше не идет `\d`. Квантификатор `?` говорит нам о том, что это дальше в нашей группе условие
необязательное, а именно `!` - отсутствует `\d` - любая цифра

Проверим по этим вариантам:  
`19.45.234` - null  
`10.34.23` - [`10.34.23`]  
`10.34.2345` - [`10.34.2345`]  
`10.34.234578` - [`10.34.234578`] - не этого мы ждали  

Во-первых, давайте левую часть оптимизируем:
`(\d{2}\.){2}`  
Во-вторых, сделаем также ограничение на символы в конце шаблона:
`(\d{4}|\d{2})(?!\d)`  

