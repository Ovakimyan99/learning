Получается так, что независимо от структуры данных, мы должны сделать итератор,
который сможет пройтись и вернуть одинаковую структуру данных

Я о следующем:
```
const a = {
    a: 1,
    b: 2,
} 

const b = [1, 2, 3]

function objToIter() {}

function arrToIter(obj) {}
```

Проитерировать оба типа данных возможно, если он примет форму:
```
{next() {}}

// и будет возвращать:
{value: ..., done: false} и метод next, если не последний
```

Для этого были созданы итераторы, которые есть у каких-то типов данных под капотом.
```
const b = [];
b[Symbol.iterator]();

for (const el = b.next(); !el.done; el = b.next()) {}
```

Вот так выглядит цикл с итератором. Для этого же и были созданы Symbol.
Но это выглядит громоздко и недуобно, поэтому создали другой цикл:

```
for (let el of b) {} - цикл for of
```

Вопрос, будет ли это работать так:
```
for (let el of b[Symbol.iterator]()) {}
```

Да, будет. И перебирать он будет по итератору, но в этом нет нужды, потому что
под капотом он перебирает по итератору.

Благодаря этому наш код становится более декларативным и полиморфным (изменяем входные
параметры, а тело остается прежним):  
```
function log(param) {
    for (const el of param) {
        console.log(el);
    }
}

log([1, 2, 3])
log(new Set[1, 2, 3])
log('[1, 2, 3]')
```
Но так не сработает с объектом. Потому что в его поведении по умолчанию нет итераторов.
Что же это означает? Раз его нет, то мы можем добавить!
```
const a =  {
    a: 1,
    b: 2,
    
    [Symbol.iterator]() {
        return {
            next() {}
        }
    }
}
```
И ей должно быть присуще все, что мы говорили ранее. У него должен быть
объект со св-вами done и value. Так мы приходим к реализации `классического автомата`ю
И также внутри есть состояние курсора, которые изменяется, указывая на то, где мы
находимся.

```
const a =  {
    a: 1,
    b: 2,
    
    [Symbol.iterator]() {
        let cursor = 0;
        const keys = Object.keys(this);

        return {
            next: () => {
                const  currCursor = cursor;
                cursor++;
                
                return {
                    value: this[keys[currCursor]],
                    done: currCursor >= keys.length
                };
            }
        }
    }
}
```
Теперь мы в `log` можем передать `a` и он заработает.
