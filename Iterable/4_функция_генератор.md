## Функция генератор
Тот обход бинарного дерева - это жесть. Такое постоянно писать в коде неприятно.
И одно из областей применения функций генераторов - это генерация итераторов или
фабрика итераторов.

Что такое генераторы и как они записываются?  
Это обычная функция. Обычная, но не обычная:  

```
funciton* funcName() {}

Или 

const foo = function* () {}
```
Arrow func генератором быть не может.

Что эта звездочка нам говорит?
И чтобы понять, что она говорит, вспомним, что мы хотим:  
Мы хотим обходить цикл, который смог бы на каждом действии приостанавливаться и дожидаться
последующего вызова.

Сработала бы такая функция?  
```
function iter(obj) {
    for (const key in obj) {
        return {
            value: obj[key],
            done: false
        }
    }
    
    return {value: undefined, done: true}
}
```

Нет, не сработало бы, потому что `return` в цикле сделает сразу выход на первом элементе.
Ни о каком продвижении вперед реи быть не может.

Если функция сделала `return`, то ее локальные переменные уничтожаются, то что вернулось, возвращается.

Получается, нам нужен такой `return`, который возвращает значения из функции. А локальные переменные функции
не уничтожались бы. То есть состояние функции не уничтожалось, а приостанавливалось. И дальше, когда
мы вызовем функцию еще раз, она проснулась и продолжила с того места, на котором остановилась.

### Yield
Для этого придумали оператор `yield`, который может быть использован только в функции
генераторе.

Если выполнить эту функцию:
```
function* iter(obj) {
    for (const key in obj) {
        yield {
            value: obj[key],
            done: false
        }
    }
}

const a = iter({a: 1, b: 2});
```
То результатом ее выполнения будет некоторый итератор, а именно объект с методом
next.

Если начать этот метод `next` вызывать, то:
```
// {value: 1, done: false}
a.next();

// {value: 2, done: false}
a.next();

// {value: undefined, done: true}
a.next();
```

И за счет этого `yield` мы добились того, что функция возвращает промежуточное
значение и ждет последующего вызова.

---
Если бы в нашей функции генераторе в конце был return:

```
function* iter(obj) {
    for (const key in obj) {
        yield {
            value: obj[key],
            done: false
        }
    }
    
    return 1; // эта строчка
}
```

То, вместо `{value: undefined, done: true}` нам прилетело бы `{value: 1, done: true}`.

А что, если вместо return стоял бы yield?  
Тогда он вернул бы `{value: 1, done: false}` и на следующий вызов `next` вернулось бы  
`{value: undefined, done: true}`

---
Теперь, если попробуем абстрактно сказать, что такое генератор, то это удобная фабрика создания
конечных автоматов.
