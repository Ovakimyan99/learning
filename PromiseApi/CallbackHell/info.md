JavaScript - это однопоточный язык программирования, который работает в среде. То есть сам по себе он не вызывается и не отрабаывает в воздухе. Ему нужна среда: браузер, nodejs... Ему нашли большое применение при том, что исходно его целью была работа в браузере на клиенте.

При этом в разных средах - на уровне окружения - у нас есть возможность создавать дополнительные потоки для исполнения кода. Например, в браузере - это `Web Workers API`. В node в последних его версиях появились потоки, а до этого были специальные библиотеки.

Можно сказать, что в Js они существуют, но на уровне языка их нет, только на уровне окружения.

Но для ассинхронности нам не нужны дополнительные потоки. Было бы странно, если для 5 ассинхронных задач нам требовалось 5 потоков, а для 100 соответственно 100. Поэтому в JavaScript есть сложный и интересный механизм EventLoop.

Рассмотрим пару строк:
```
console.log(1);

setTimeout(() => {
  console.log(2);
});

console.log(3);
```

Сначала выполнится синхронный код. Потом он дойдет до `setTimeout` и создаст макротаск из `callback: () =>`, который выполнится когда-то там. Потом продолжить идти по коду и дойдет до тройки.

Когда выполнится наш код? В зависимости от того, как задекларирована наша логика.

Например, мы навесим обработчик события и будем дожидаться клика: мы не знаем, когда пользователь нажмет на кнопку, но мы точно знаем, что это произойдет не сейчас - ассинхронность.

Так у нас сначала выведется 1, 3, 2;

Исторически так сложилось, что с ассинхронностью работали с помощью `callback`.

Callback - функция, которая передается в качестве параметра другой функции и вызывается в нужный для нас момент.

Хорошо, с ассинхронностью мы можем работать с помощью `callback`, но что насчет обработки различных ошибок в неудачных случаях? (*)

Как ведет себя `try catch` при работе с ассинхронными данными и можем ли мы обрабатывать ассинхронные функции? Подробно эту тему я раскрою в отдельной теме: "исключения и ошибки"