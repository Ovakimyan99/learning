У промисов есть очень важная особенность: then возвращает нам промис,
у которого есть свой `then` и другие методы. 
```
new Promise().then()
```

И логика then такова, что возвращаемое значение одного `then`, станет входным параметром следующего. Например:
```
new Promise((res) => {
  setTimeout(() => res('Пишем код'), 205);
})
  .then(res => res + 7) // 'Пишем код' + 7
  .then(console.log)  // 'Пишем код7'
```

Также представим ситуацию, когда у нас выбрасывается exception. Как нам обрабатывать ошибку?

Важно знать, что у промиса есть 3 статуса:
1. Pending
2. Fulfilled
3. Rejected

В состоянии `Pending` мы находимсы в ожидании и у нас нет результата выполнения. В статусе `Fulfilled` у анс есть результат и мы можем переходить к следующему then. При `Rejected` мы точно знаем, что что-то пошло не так, ошибка.

И у промисов есть очень удобный метод `catch`:
```
new Promise((_, rej) => {
  setTimeout(() => rej('Пишем код'), 205);
})
  .then(res => res + 7) // Проигнорирован
  .catch(error => {
    console.error(error);
    return 'Продолжаем работу';
  })
  .then(console.log)  // 'Продолжаем работу'
```

Если у нас выбросилась ошибка, то мы будем игнорировать все `then` до тех пор, пока не дойдем до `catch`.

Отсюда можно заметить, что `catch` возвращает промис, внутри мы можем обработать ошибку и вернуть значение, которое дальше можно перехватить.

Хорошо, а что если наш then будет возвращать промис?
Да, до этого мы возвращали примитивы, при этом у промисов есть очень классное св-во "распаковывать" промис, который мы передаем. Поэтому в результат следующего `then` попадет результат передаваемого промиса.

Давайте рассмотрим пример с doSomething в исполнении с промисами:
```
  function doSomething() {
    openFile(path)
      .then(getHash(normalize))
      .then((hash) => fetch(`/foo?hash=${hash}`))
      .then((data) => writeFile(path, data))
      .catch(console.error);
  }
```
Таков код с применением промисов. В сравнении он сильно лучше, чем прошлые варианты.

В стандарте ES7 / ES2018 промисы немного улучшили и добавили синтаксический сахар в виде async/await.

Что можно сказать про этот код?
```
async function doSomething(path) {
  return 1;
}
```

`async` всегда обращает нашу функцию в промис, который в данном случае зарезолвился со значением единички.

Если мы вернем другой промис, то семантика сохранится и вернется распакованный промис, который либо зафулфилдится, либо зареджектится.

А какие у этого могут быть проблемы?
Что с этим может быть не так?

Давайте рассмотрим пример:
```
new Promise(async (resolve) => {
  window.addEventLisener('sb',() => {});
  resolve(1);
})
```
Можно обнаружить, что у нас есть ошибка в `window.addEventListener` в методе. Также мы передаем несуществующее событие.  Можно ожидать, что это выкинет exception, который мы можем обработать.

Но ключевое здесь - это async. Как мы уже сказали, если рассахарить, то это превращается в промис. И примет это следующий вид:
```
new Promise((resolve) => {
  new Promise((resolve2) => {
    window.addEventLisener('sb',() => {});
    resolve2(1);
  }).then(resolve);
})
```
По-хорошему, чтобы он превращался в такой код:
```
new Promise((resolve, reject) => {
  new Promise((resolve2) => {
    window.addEventLisener('sb',() => {});
    resolve2(1);
  }).then(resolve, reject);
})
```
но такого не происходит. И получается, что промис не резолвится, не реджектится и зависает в вечном Pending. Вместе с ним, поскольку функции JavaScript создают замыкания, зависают в памяти все ссылки на замыкания. Если виртуальная машина сама не сообразит, что ссылка мертвая и ее надо убить, то у нас получается утека памяти.

Поэтому надо помнить, что надо вызывать не только resolve, но и reject, кроме тех случаев, где закрытая синхронная операция. И не стоит использовать async параметр внутри промиса, а если используем, то нужно помнить, что ошибку необходимо обрабатывать. Как обработать? Через `try catch` своими ручками:
```
new Promise(async (resolve, reject) => {
  try {
    window.addEventLisener('sb',() => {});
    resolve2(1);
  } catch(e) {
    reject(e);
  }
})
```

// ------  
// pending  
// fulfilled then finally (еще не говорили об этом)  
// rejected then (2 аргумент) catch finally  
// ------

На текущем этапе достаточно важно понимать между `catch` и вторым параметром `then`.

Рассмотрим пример:
```
new Promise((res) => res(1..round()))
  .then(r => r + 1)
  .then(v => v * 2)
  .catch(e => 6)
```

Мы пытаемся вызвать метод `round` у числа, хотя такого метода не существует. Больше скажу, у нас синтаксическая ошибка присутствует. И поскольку это уходит в состояние `rejected`, то мы пропустим then и дойдем до catch, где придадим новое значение.

Хорошо, мы знаем, что во втором аргументе then можно передать функцию, чтобы обрабатывать ошибки, сработает ли это:
```
new Promise((res) => res(1))
  .then(r => (r + 1).round(), (err) => 1)
  .then(v => v * 2)
  .catch(e => 6)
```
`Ответ нет`, не сработает, потому что он сработает на ошибку внутри родительского промиса: `new Promise((res) => res(1))`. Поэтому надо использовать catch, который сработает гарантированно в любом случае и нормализует промис.

А что если мы не обработаем ошибку? Вот возьмем и не напишем `catch`.
В спецификации продумали и это. В таком случае будет срабатывать глобальное событие у window:
`window.addEventListener('unhandledrejection', () => {})`

То же самое есть в node, только у глобального объекта process. Но лучше, конечно, обрабатывать ошибки по мере поступления, чтобы сохранять контекст.

Теперь давайте еще раз рассмотрим пример с вызовом промиса в промисе:
```
new Promise((resolve) => {
  resolve(sleep(100).then(() => 10));
})

// То же самое, что и
new Promise((resolve, reject) => {
  sleep(100).then(() => 10).then(resolve, reject)
})
```
Но второй вариант надо помнить как "отче наш", потому что в этом сила промисов.

Теперь поговорим про
### Finally

